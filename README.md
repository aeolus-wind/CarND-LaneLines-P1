#**Finding Lane Lines on the Road** 

[![Udacity - Self-Driving Car NanoDegree](https://s3.amazonaws.com/udacity-sdc/github/shield-carnd.svg)](http://www.udacity.com/drive)

### A Quick Write-up of my Work


I completed this project as part of Udacity's Self-Driving Car NanoDegree. In it, we learn the basics of computer vision and get an excellent introduction to OpenCV. Most surprising to me was how elegant the math is in Computer Vision. Notably, I love the ideas behind the Hough Line Detection Algorithm. The algorithm is among the most practical and elegant applications of clear mathematical thinking that I have encountered. The heart of the algorithm gets at the question of representation in mathematics/engineering and explores it in the most precise way. The question, "What is the most useful representation of a mathematical object?" is one of the most important in STEM fields. The Hough Line Detection Algorithm answers the question, "what is the most useful representation of a line?" It uses a deep understanding of this topic, facts of which are accessible to a high school student, to derive a simple, elegant, and efficient way to discover the most likely lines in an image. 

Throughout this project, I considered this question of representation, and wondered how I might apply it to form an elegant solution to the problem. In the project, I explore 3 different ways of representing the data to find four lines which represent two lanes. The ideas and their applications are as follows:

#### Precondition to everything that follows:
##### After using the Hough Line Detection Algorithm, you have a set of lines and you now need to split it into four groups. It is easy to do a first split into two groups based on the fact that lines in the left lane have negative slope and those in the right lane have positive slope. Once you have these two groups, the ideas below apply.

 1. If the image is clean, each of the two groups will contain two lines. If you do a linear regression on the points that compose those lines, the result will be the average. This means that this average line can now be used as a separating plane: you split the points based on the sign of their residuals and apply linear regression to these points.
 1. You can consider each line in a group as a candidate line. You want to figure out from these candidates the 'best possible line.' In this regards, each line segment has 3 useful properties, the length, the slope, and the projection onto the bottom of the picture. The last property is less obvious. The idea is that due to geometry, the lines will spread out as they reach the bottom. Thus the point where the lines hit the bottom will distinguish candidate lines the most from each other. Once you have this representation for candidate lines, you can play around with any number of ideas from clustering. The idea method will discover all 'natural' clusters, remove clusters that are outliers, and check for a final condition where we have four clusters and they are spaced appropriately on the bottom of the picture with proper slopes. Then you take a average weighted by the length of the lines for the final answer. This algorithm is both natural considering the goals of the problem and robust.
 1. The final representation considers each line segment as a starting point that points in a direction. You take a line segment and move along the direction is pointing (extending from around its end point) and see if you 'collide' with another starting point. You repeat this process until there are no more collisions. Everything that you find is now grouped together. You continue this process until you have used up all discovered line segments. Then you search through your groups and find the four appropriate groups.

 Of course, the 'mathematical elegance' of an idea often does not manifest when you have to engineer it into the real world. I found that messy data and at times clunky coding interfered with my results. Moreover, you always face time constraints. In the end, I had to settle with the first idea because it is the easiest to implement, and the results are pretty good. Despite these positives, idea #1 does not naturally deal with outliers, and I ended up augenting it with simple strategies to remove outliers and smooth the results. At this point, you might be wondering why idea #2 didn't work?

There were two reasons the second strategy didn't work. The first reason is that the clustering methods that I used to remove outliers weren't natural as I would have wanted. I favored simplicity when I was prototyping. The second reason gets at a major assumption that I made when exploring how best to apply the Hough Line Detection Algorithm. I focused too much on finding those lines which actually appeared in the image. Because of this, I made the parameters too strict. This is an issue because there are always dashed lines in the video and in some video frames, there aren't enough dashes for a robust result. I should have relaxed this restriction and let the Hough Lines algorithm find lines that extended between dashes. This would give me longer, more robust lines that would aid any of the 3 methods I discuss. 

In all, the project was a lot of fun, and I learned a tremendous amount. I'd like to thank Udacity for putting it together. Thanks for reading!